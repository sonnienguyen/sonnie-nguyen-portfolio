!function(g){var I={};function C(n){if(I[n])return I[n].exports;var A=I[n]={i:n,l:!1,exports:{}};return g[n].call(A.exports,A,A.exports,C),A.l=!0,A.exports}C.m=g,C.c=I,C.d=function(g,I,n){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:n})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var n=Object.create(null);if(C.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var A in g)C.d(n,A,function(I){return g[I]}.bind(null,A));return n},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="",C(C.s=1)}([function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nexports.default = ResponsiveNav;\n/**\n * responsive-nav.js 1.0.39\n * https://github.com/viljamis/responsive-nav.js\n * http://responsive-nav.com\n *\n * Copyright (c) 2015 @viljamis\n * Available under the MIT license\n */\n\nfunction ResponsiveNav(document, window, index) {\n  var responsiveNav = function responsiveNav(el, options) {\n\n    var computed = !!window.getComputedStyle;\n\n    /**\n     * getComputedStyle polyfill for old browsers\n     */\n    if (!computed) {\n      window.getComputedStyle = function (el) {\n        this.el = el;\n        this.getPropertyValue = function (prop) {\n          var re = /(\\-([a-z]){1})/g;\n          if (prop === "float") {\n            prop = "styleFloat";\n          }\n          if (re.test(prop)) {\n            prop = prop.replace(re, function () {\n              return arguments[2].toUpperCase();\n            });\n          }\n          return el.currentStyle[prop] ? el.currentStyle[prop] : null;\n        };\n        return this;\n      };\n    }\n    /* exported addEvent, removeEvent, getChildren, setAttributes, addClass, removeClass, forEach */\n\n    /**\n     * Add Event\n     * fn arg can be an object or a function, thanks to handleEvent\n     * read more at: http://www.thecssninja.com/javascript/handleevent\n     *\n     * @param  {element}  element\n     * @param  {event}    event\n     * @param  {Function} fn\n     * @param  {boolean}  bubbling\n     */\n    var addEvent = function addEvent(el, evt, fn, bubble) {\n      if ("addEventListener" in el) {\n        // BBOS6 doesn\'t support handleEvent, catch and polyfill\n        try {\n          el.addEventListener(evt, fn, bubble);\n        } catch (e) {\n          if ((typeof fn === "undefined" ? "undefined" : _typeof(fn)) === "object" && fn.handleEvent) {\n            el.addEventListener(evt, function (e) {\n              // Bind fn as this and set first arg as event object\n              fn.handleEvent.call(fn, e);\n            }, bubble);\n          } else {\n            throw e;\n          }\n        }\n      } else if ("attachEvent" in el) {\n        // check if the callback is an object and contains handleEvent\n        if ((typeof fn === "undefined" ? "undefined" : _typeof(fn)) === "object" && fn.handleEvent) {\n          el.attachEvent("on" + evt, function () {\n            // Bind fn as this\n            fn.handleEvent.call(fn);\n          });\n        } else {\n          el.attachEvent("on" + evt, fn);\n        }\n      }\n    },\n\n\n    /**\n     * Remove Event\n     *\n     * @param  {element}  element\n     * @param  {event}    event\n     * @param  {Function} fn\n     * @param  {boolean}  bubbling\n     */\n    removeEvent = function removeEvent(el, evt, fn, bubble) {\n      if ("removeEventListener" in el) {\n        try {\n          el.removeEventListener(evt, fn, bubble);\n        } catch (e) {\n          if ((typeof fn === "undefined" ? "undefined" : _typeof(fn)) === "object" && fn.handleEvent) {\n            el.removeEventListener(evt, function (e) {\n              fn.handleEvent.call(fn, e);\n            }, bubble);\n          } else {\n            throw e;\n          }\n        }\n      } else if ("detachEvent" in el) {\n        if ((typeof fn === "undefined" ? "undefined" : _typeof(fn)) === "object" && fn.handleEvent) {\n          el.detachEvent("on" + evt, function () {\n            fn.handleEvent.call(fn);\n          });\n        } else {\n          el.detachEvent("on" + evt, fn);\n        }\n      }\n    },\n\n\n    /**\n     * Get the children of any element\n     *\n     * @param  {element}\n     * @return {array} Returns matching elements in an array\n     */\n    getChildren = function getChildren(e) {\n      if (e.children.length < 1) {\n        throw new Error("The Nav container has no containing elements");\n      }\n      // Store all children in array\n      var children = [];\n      // Loop through children and store in array if child != TextNode\n      for (var i = 0; i < e.children.length; i++) {\n        if (e.children[i].nodeType === 1) {\n          children.push(e.children[i]);\n        }\n      }\n      return children;\n    },\n\n\n    /**\n     * Sets multiple attributes at once\n     *\n     * @param {element} element\n     * @param {attrs}   attrs\n     */\n    setAttributes = function setAttributes(el, attrs) {\n      for (var key in attrs) {\n        el.setAttribute(key, attrs[key]);\n      }\n    },\n\n\n    /**\n     * Adds a class to any element\n     *\n     * @param {element} element\n     * @param {string}  class\n     */\n    addClass = function addClass(el, cls) {\n      if (el.className.indexOf(cls) !== 0) {\n        el.className += " " + cls;\n        el.className = el.className.replace(/(^\\s*)|(\\s*$)/g, "");\n      }\n    },\n\n\n    /**\n     * Remove a class from any element\n     *\n     * @param  {element} element\n     * @param  {string}  class\n     */\n    removeClass = function removeClass(el, cls) {\n      var reg = new RegExp("(\\\\s|^)" + cls + "(\\\\s|$)");\n      el.className = el.className.replace(reg, " ").replace(/(^\\s*)|(\\s*$)/g, "");\n    },\n\n\n    /**\n     * forEach method that passes back the stuff we need\n     *\n     * @param  {array}    array\n     * @param  {Function} callback\n     * @param  {scope}    scope\n     */\n    forEach = function forEach(array, callback, scope) {\n      for (var i = 0; i < array.length; i++) {\n        callback.call(scope, i, array[i]);\n      }\n    };\n\n    var nav,\n        opts,\n        navToggle,\n        styleElement = document.createElement("style"),\n        htmlEl = document.documentElement,\n        hasAnimFinished,\n        isMobile,\n        navOpen;\n\n    var ResponsiveNav = function ResponsiveNav(el, options) {\n      var i;\n\n      /**\n       * Default options\n       * @type {Object}\n       */\n      this.options = {\n        animate: true, // Boolean: Use CSS3 transitions, true or false\n        transition: 284, // Integer: Speed of the transition, in milliseconds\n        label: "", // String: Label for the navigation toggle\n        insert: "", // String: Insert the toggle before or after the navigation\n        customToggle: "", // Selector: Specify the ID of a custom toggle\n        closeOnNavClick: false, // Boolean: Close the navigation when one of the links are clicked\n        openPos: "relative", // String: Position of the opened nav, relative or static\n        navClass: "nav-collapse", // String: Default CSS class. If changed, you need to edit the CSS too!\n        navActiveClass: "js-nav-active", // String: Class that is added to <html> element when nav is active\n        jsClass: "js", // String: \'JS enabled\' class which is added to <html> element\n        init: function init() {}, // Function: Init callback\n        open: function open() {}, // Function: Open callback\n        close: function close() {} // Function: Close callback\n      };\n\n      // User defined options\n      for (i in options) {\n        this.options[i] = options[i];\n      }\n\n      // Adds "js" class for <html>\n      addClass(htmlEl, this.options.jsClass);\n\n      // Wrapper\n      this.wrapperEl = el.replace("#", "");\n\n      // Try selecting ID first\n      if (document.getElementById(this.wrapperEl)) {\n        this.wrapper = document.getElementById(this.wrapperEl);\n\n        // If element with an ID doesn\'t exist, use querySelector\n      } else if (document.querySelector(this.wrapperEl)) {\n        this.wrapper = document.querySelector(this.wrapperEl);\n\n        // If element doesn\'t exists, stop here.\n      } else {\n        throw new Error("The nav element you are trying to select doesn\'t exist");\n      }\n\n      // Inner wrapper\n      this.wrapper.inner = getChildren(this.wrapper);\n\n      // For minification\n      opts = this.options;\n      nav = this.wrapper;\n\n      // Init\n      this._init(this);\n    };\n\n    ResponsiveNav.prototype = {\n\n      /**\n       * Unattaches events and removes any classes that were added\n       */\n      destroy: function destroy() {\n        this._removeStyles();\n        removeClass(nav, "closed");\n        removeClass(nav, "opened");\n        removeClass(nav, opts.navClass);\n        removeClass(nav, opts.navClass + "-" + this.index);\n        removeClass(htmlEl, opts.navActiveClass);\n        nav.removeAttribute("style");\n        nav.removeAttribute("aria-hidden");\n\n        removeEvent(window, "resize", this, false);\n        removeEvent(window, "focus", this, false);\n        removeEvent(document.body, "touchmove", this, false);\n        removeEvent(navToggle, "touchstart", this, false);\n        removeEvent(navToggle, "touchend", this, false);\n        removeEvent(navToggle, "mouseup", this, false);\n        removeEvent(navToggle, "keyup", this, false);\n        removeEvent(navToggle, "click", this, false);\n\n        if (!opts.customToggle) {\n          navToggle.parentNode.removeChild(navToggle);\n        } else {\n          navToggle.removeAttribute("aria-hidden");\n        }\n      },\n\n      /**\n       * Toggles the navigation open/close\n       */\n      toggle: function toggle() {\n        if (hasAnimFinished === true) {\n          if (!navOpen) {\n            this.open();\n          } else {\n            this.close();\n          }\n        }\n      },\n\n      /**\n       * Opens the navigation\n       */\n      open: function open() {\n        if (!navOpen) {\n          removeClass(nav, "closed");\n          addClass(nav, "opened");\n          addClass(htmlEl, opts.navActiveClass);\n          addClass(navToggle, "active");\n          nav.style.position = opts.openPos;\n          setAttributes(nav, { "aria-hidden": "false" });\n          navOpen = true;\n          opts.open();\n        }\n      },\n\n      /**\n       * Closes the navigation\n       */\n      close: function close() {\n        if (navOpen) {\n          addClass(nav, "closed");\n          removeClass(nav, "opened");\n          removeClass(htmlEl, opts.navActiveClass);\n          removeClass(navToggle, "active");\n          setAttributes(nav, { "aria-hidden": "true" });\n\n          // If animations are enabled, wait until they finish\n          if (opts.animate) {\n            hasAnimFinished = false;\n            setTimeout(function () {\n              nav.style.position = "absolute";\n              hasAnimFinished = true;\n            }, opts.transition + 10);\n\n            // Animations aren\'t enabled, we can do these immediately\n          } else {\n            nav.style.position = "absolute";\n          }\n\n          navOpen = false;\n          opts.close();\n        }\n      },\n\n      /**\n       * Resize is called on window resize and orientation change.\n       * It initializes the CSS styles and height calculations.\n       */\n      resize: function resize() {\n\n        // Resize watches navigation toggle\'s display state\n        if (window.getComputedStyle(navToggle, null).getPropertyValue("display") !== "none") {\n\n          isMobile = true;\n          setAttributes(navToggle, { "aria-hidden": "false" });\n\n          // If the navigation is hidden\n          if (nav.className.match(/(^|\\s)closed(\\s|$)/)) {\n            setAttributes(nav, { "aria-hidden": "true" });\n            nav.style.position = "absolute";\n          }\n\n          this._createStyles();\n          this._calcHeight();\n        } else {\n\n          isMobile = false;\n          setAttributes(navToggle, { "aria-hidden": "true" });\n          setAttributes(nav, { "aria-hidden": "false" });\n          nav.style.position = opts.openPos;\n          this._removeStyles();\n        }\n      },\n\n      /**\n       * Takes care of all even handling\n       *\n       * @param  {event} event\n       * @return {type} returns the type of event that should be used\n       */\n      handleEvent: function handleEvent(e) {\n        var evt = e || window.event;\n\n        switch (evt.type) {\n          case "touchstart":\n            this._onTouchStart(evt);\n            break;\n          case "touchmove":\n            this._onTouchMove(evt);\n            break;\n          case "touchend":\n          case "mouseup":\n            this._onTouchEnd(evt);\n            break;\n          case "click":\n            this._preventDefault(evt);\n            break;\n          case "keyup":\n            this._onKeyUp(evt);\n            break;\n          case "focus":\n          case "resize":\n            this.resize(evt);\n            break;\n        }\n      },\n\n      /**\n       * Initializes the widget\n       */\n      _init: function _init() {\n        this.index = index++;\n\n        addClass(nav, opts.navClass);\n        addClass(nav, opts.navClass + "-" + this.index);\n        addClass(nav, "closed");\n        hasAnimFinished = true;\n        navOpen = false;\n\n        this._closeOnNavClick();\n        this._createToggle();\n        this._transitions();\n        this.resize();\n\n        /**\n         * On IE8 the resize event triggers too early for some reason\n         * so it\'s called here again on init to make sure all the\n         * calculated styles are correct.\n         */\n        var self = this;\n        setTimeout(function () {\n          self.resize();\n        }, 20);\n\n        addEvent(window, "resize", this, false);\n        addEvent(window, "focus", this, false);\n        addEvent(document.body, "touchmove", this, false);\n        addEvent(navToggle, "touchstart", this, false);\n        addEvent(navToggle, "touchend", this, false);\n        addEvent(navToggle, "mouseup", this, false);\n        addEvent(navToggle, "keyup", this, false);\n        addEvent(navToggle, "click", this, false);\n\n        /**\n         * Init callback here\n         */\n        opts.init();\n      },\n\n      /**\n       * Creates Styles to the <head>\n       */\n      _createStyles: function _createStyles() {\n        if (!styleElement.parentNode) {\n          styleElement.type = "text/css";\n          document.getElementsByTagName("head")[0].appendChild(styleElement);\n        }\n      },\n\n      /**\n       * Removes styles from the <head>\n       */\n      _removeStyles: function _removeStyles() {\n        if (styleElement.parentNode) {\n          styleElement.parentNode.removeChild(styleElement);\n        }\n      },\n\n      /**\n       * Creates Navigation Toggle\n       */\n      _createToggle: function _createToggle() {\n\n        // If there\'s no toggle, let\'s create one\n        if (!opts.customToggle) {\n          var toggle = document.createElement("div");\n          var icon = document.createElement("div");\n          toggle.innerHTML = opts.label;\n          setAttributes(toggle, {\n            "href": "#",\n            "class": "nav-toggle"\n          });\n          icon.className = \'nav-toggle-icon\';\n          toggle.appendChild(icon);\n\n          // Determine where to insert the toggle\n          if (opts.insert === "after") {\n            nav.parentNode.insertBefore(toggle, nav.nextSibling);\n          } else {\n            nav.parentNode.insertBefore(toggle, nav);\n          }\n\n          navToggle = toggle;\n\n          // There is a toggle already, let\'s use that one\n        } else {\n          var toggleEl = opts.customToggle.replace("#", "");\n\n          if (document.getElementById(toggleEl)) {\n            navToggle = document.getElementById(toggleEl);\n          } else if (document.querySelector(toggleEl)) {\n            navToggle = document.querySelector(toggleEl);\n          } else {\n            throw new Error("The custom nav toggle you are trying to select doesn\'t exist");\n          }\n        }\n      },\n\n      /**\n       * Closes the navigation when a link inside is clicked.\n       */\n      _closeOnNavClick: function _closeOnNavClick() {\n        if (opts.closeOnNavClick) {\n          var links = nav.getElementsByTagName("a"),\n              self = this;\n          forEach(links, function (i, el) {\n            addEvent(links[i], "click", function () {\n              if (isMobile) {\n                self.toggle();\n              }\n            }, false);\n          });\n        }\n      },\n\n      /**\n       * Prevents the default functionality.\n       *\n       * @param  {event} event\n       */\n      _preventDefault: function _preventDefault(e) {\n        if (e.preventDefault) {\n          if (e.stopImmediatePropagation) {\n            e.stopImmediatePropagation();\n          }\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n\n          // This is strictly for old IE\n        } else {\n          e.returnValue = false;\n        }\n      },\n\n      /**\n       * On touch start we get the location of the touch.\n       *\n       * @param  {event} event\n       */\n      _onTouchStart: function _onTouchStart(e) {\n        if (!Event.prototype.stopImmediatePropagation) {\n          this._preventDefault(e);\n        }\n        this.startX = e.touches[0].clientX;\n        this.startY = e.touches[0].clientY;\n        this.touchHasMoved = false;\n\n        /**\n         * Remove mouseup event completely here to avoid\n         * double triggering the event.\n         */\n        removeEvent(navToggle, "mouseup", this, false);\n      },\n\n      /**\n       * Check if the user is scrolling instead of tapping.\n       *\n       * @param  {event} event\n       */\n      _onTouchMove: function _onTouchMove(e) {\n        if (Math.abs(e.touches[0].clientX - this.startX) > 10 || Math.abs(e.touches[0].clientY - this.startY) > 10) {\n          this.touchHasMoved = true;\n        }\n      },\n\n      /**\n       * On touch end toggle the navigation.\n       *\n       * @param  {event} event\n       */\n      _onTouchEnd: function _onTouchEnd(e) {\n        this._preventDefault(e);\n        if (!isMobile) {\n          return;\n        }\n\n        // If the user isn\'t scrolling\n        if (!this.touchHasMoved) {\n\n          // If the event type is touch\n          if (e.type === "touchend") {\n            this.toggle();\n            return;\n\n            // Event type was click, not touch\n          } else {\n            var evt = e || window.event;\n\n            // If it isn\'t a right click, do toggling\n            if (!(evt.which === 3 || evt.button === 2)) {\n              this.toggle();\n            }\n          }\n        }\n      },\n\n      /**\n       * For keyboard accessibility, toggle the navigation on Enter\n       * keypress too.\n       *\n       * @param  {event} event\n       */\n      _onKeyUp: function _onKeyUp(e) {\n        var evt = e || window.event;\n        if (evt.keyCode === 13) {\n          this.toggle();\n        }\n      },\n\n      /**\n       * Adds the needed CSS transitions if animations are enabled\n       */\n      _transitions: function _transitions() {\n        if (opts.animate) {\n          var objStyle = nav.style,\n              transition = "max-height " + opts.transition + "ms";\n\n          objStyle.WebkitTransition = objStyle.MozTransition = objStyle.OTransition = objStyle.transition = transition;\n        }\n      },\n\n      /**\n       * Calculates the height of the navigation and then creates\n       * styles which are later added to the page <head>\n       */\n      _calcHeight: function _calcHeight() {\n        var savedHeight = 0;\n        for (var i = 0; i < nav.inner.length; i++) {\n          savedHeight += nav.inner[i].offsetHeight;\n        }\n\n        var innerStyles = "." + opts.jsClass + " ." + opts.navClass + "-" + this.index + ".opened{max-height:" + savedHeight + "px !important} ." + opts.jsClass + " ." + opts.navClass + "-" + this.index + ".opened.dropdown-active {max-height:9999px !important}";\n\n        if (styleElement.styleSheet) {\n          styleElement.styleSheet.cssText = innerStyles;\n        } else {\n          styleElement.innerHTML = innerStyles;\n        }\n\n        innerStyles = "";\n      }\n\n    };\n\n    /**\n     * Return new Responsive Nav\n     */\n    return new ResponsiveNav(el, options);\n  };\n\n  window.responsiveNav = responsiveNav;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvdmVuZG9yL3Jlc3BvbnNpdmVOYXYuanM/NmFlMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHJlc3BvbnNpdmUtbmF2LmpzIDEuMC4zOVxuICogaHR0cHM6Ly9naXRodWIuY29tL3ZpbGphbWlzL3Jlc3BvbnNpdmUtbmF2LmpzXG4gKiBodHRwOi8vcmVzcG9uc2l2ZS1uYXYuY29tXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEB2aWxqYW1pc1xuICogQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJlc3BvbnNpdmVOYXYoZG9jdW1lbnQsIHdpbmRvdywgaW5kZXgpIHtcbiAgdmFyIHJlc3BvbnNpdmVOYXYgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcblxuICAgIHZhciBjb21wdXRlZCA9ICEhd2luZG93LmdldENvbXB1dGVkU3R5bGU7XG5cbiAgICAvKipcbiAgICAgKiBnZXRDb21wdXRlZFN0eWxlIHBvbHlmaWxsIGZvciBvbGQgYnJvd3NlcnNcbiAgICAgKi9cbiAgICBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5nZXRQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgIHZhciByZSA9IC8oXFwtKFthLXpdKXsxfSkvZztcbiAgICAgICAgICBpZiAocHJvcCA9PT0gXCJmbG9hdFwiKSB7XG4gICAgICAgICAgICBwcm9wID0gXCJzdHlsZUZsb2F0XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZS50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgICBwcm9wID0gcHJvcC5yZXBsYWNlKHJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMl0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZWwuY3VycmVudFN0eWxlW3Byb3BdID8gZWwuY3VycmVudFN0eWxlW3Byb3BdIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH1cbiAgICAvKiBleHBvcnRlZCBhZGRFdmVudCwgcmVtb3ZlRXZlbnQsIGdldENoaWxkcmVuLCBzZXRBdHRyaWJ1dGVzLCBhZGRDbGFzcywgcmVtb3ZlQ2xhc3MsIGZvckVhY2ggKi9cblxuICAgIC8qKlxuICAgICAqIEFkZCBFdmVudFxuICAgICAqIGZuIGFyZyBjYW4gYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIHRoYW5rcyB0byBoYW5kbGVFdmVudFxuICAgICAqIHJlYWQgbW9yZSBhdDogaHR0cDovL3d3dy50aGVjc3NuaW5qYS5jb20vamF2YXNjcmlwdC9oYW5kbGVldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtICB7ZWxlbWVudH0gIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gIHtldmVudH0gICAgZXZlbnRcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSAgYnViYmxpbmdcbiAgICAgKi9cbiAgICB2YXIgYWRkRXZlbnQgPSBmdW5jdGlvbiAoZWwsIGV2dCwgZm4sIGJ1YmJsZSkge1xuICAgICAgICBpZiAoXCJhZGRFdmVudExpc3RlbmVyXCIgaW4gZWwpIHtcbiAgICAgICAgICAvLyBCQk9TNiBkb2Vzbid0IHN1cHBvcnQgaGFuZGxlRXZlbnQsIGNhdGNoIGFuZCBwb2x5ZmlsbFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgZm4sIGJ1YmJsZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJvYmplY3RcIiAmJiBmbi5oYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBCaW5kIGZuIGFzIHRoaXMgYW5kIHNldCBmaXJzdCBhcmcgYXMgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgZm4uaGFuZGxlRXZlbnQuY2FsbChmbiwgZSk7XG4gICAgICAgICAgICAgIH0sIGJ1YmJsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcImF0dGFjaEV2ZW50XCIgaW4gZWwpIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgY2FsbGJhY2sgaXMgYW4gb2JqZWN0IGFuZCBjb250YWlucyBoYW5kbGVFdmVudFxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwib2JqZWN0XCIgJiYgZm4uaGFuZGxlRXZlbnQpIHtcbiAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KFwib25cIiArIGV2dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBCaW5kIGZuIGFzIHRoaXNcbiAgICAgICAgICAgICAgZm4uaGFuZGxlRXZlbnQuY2FsbChmbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoXCJvblwiICsgZXZ0LCBmbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBFdmVudFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge2VsZW1lbnR9ICBlbGVtZW50XG4gICAgICAgKiBAcGFyYW0gIHtldmVudH0gICAgZXZlbnRcbiAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gIGJ1YmJsaW5nXG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gKGVsLCBldnQsIGZuLCBidWJibGUpIHtcbiAgICAgICAgaWYgKFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiIGluIGVsKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBmbiwgYnViYmxlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcIm9iamVjdFwiICYmIGZuLmhhbmRsZUV2ZW50KSB7XG4gICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGZuLmhhbmRsZUV2ZW50LmNhbGwoZm4sIGUpO1xuICAgICAgICAgICAgICB9LCBidWJibGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXCJkZXRhY2hFdmVudFwiIGluIGVsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJvYmplY3RcIiAmJiBmbi5oYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoXCJvblwiICsgZXZ0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGZuLmhhbmRsZUV2ZW50LmNhbGwoZm4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmRldGFjaEV2ZW50KFwib25cIiArIGV2dCwgZm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgdGhlIGNoaWxkcmVuIG9mIGFueSBlbGVtZW50XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7ZWxlbWVudH1cbiAgICAgICAqIEByZXR1cm4ge2FycmF5fSBSZXR1cm5zIG1hdGNoaW5nIGVsZW1lbnRzIGluIGFuIGFycmF5XG4gICAgICAgKi9cbiAgICAgIGdldENoaWxkcmVuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuY2hpbGRyZW4ubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBOYXYgY29udGFpbmVyIGhhcyBubyBjb250YWluaW5nIGVsZW1lbnRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIGFsbCBjaGlsZHJlbiBpbiBhcnJheVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGNoaWxkcmVuIGFuZCBzdG9yZSBpbiBhcnJheSBpZiBjaGlsZCAhPSBUZXh0Tm9kZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZS5jaGlsZHJlbltpXS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChlLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIG11bHRpcGxlIGF0dHJpYnV0ZXMgYXQgb25jZVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbWVudFxuICAgICAgICogQHBhcmFtIHthdHRyc30gICBhdHRyc1xuICAgICAgICovXG4gICAgICBzZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGVsLCBhdHRycykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGEgY2xhc3MgdG8gYW55IGVsZW1lbnRcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgY2xhc3NcbiAgICAgICAqL1xuICAgICAgYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIGNscykge1xuICAgICAgICBpZiAoZWwuY2xhc3NOYW1lLmluZGV4T2YoY2xzKSAhPT0gMCkge1xuICAgICAgICAgIGVsLmNsYXNzTmFtZSArPSBcIiBcIiArIGNscztcbiAgICAgICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZSgvKF5cXHMqKXwoXFxzKiQpL2csXCJcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGEgY2xhc3MgZnJvbSBhbnkgZWxlbWVudFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge2VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gIGNsYXNzXG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGVsLCBjbHMpIHtcbiAgICAgICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCIoXFxcXHN8XilcIiArIGNscyArIFwiKFxcXFxzfCQpXCIpO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShyZWcsIFwiIFwiKS5yZXBsYWNlKC8oXlxccyopfChcXHMqJCkvZyxcIlwiKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogZm9yRWFjaCBtZXRob2QgdGhhdCBwYXNzZXMgYmFjayB0aGUgc3R1ZmYgd2UgbmVlZFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBhcnJheVxuICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgKiBAcGFyYW0gIHtzY29wZX0gICAgc2NvcGVcbiAgICAgICAqL1xuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHNjb3BlLCBpLCBhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICB2YXIgbmF2LFxuICAgICAgb3B0cyxcbiAgICAgIG5hdlRvZ2dsZSxcbiAgICAgIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSxcbiAgICAgIGh0bWxFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIGhhc0FuaW1GaW5pc2hlZCxcbiAgICAgIGlzTW9iaWxlLFxuICAgICAgbmF2T3BlbjtcblxuICAgIHZhciBSZXNwb25zaXZlTmF2ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICBhbmltYXRlOiB0cnVlLCAgICAgICAgICAgICAgICAgICAgLy8gQm9vbGVhbjogVXNlIENTUzMgdHJhbnNpdGlvbnMsIHRydWUgb3IgZmFsc2VcbiAgICAgICAgICB0cmFuc2l0aW9uOiAyODQsICAgICAgICAgICAgICAgICAgLy8gSW50ZWdlcjogU3BlZWQgb2YgdGhlIHRyYW5zaXRpb24sIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgIGxhYmVsOiBcIlwiLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZzogTGFiZWwgZm9yIHRoZSBuYXZpZ2F0aW9uIHRvZ2dsZVxuICAgICAgICAgIGluc2VydDogXCJcIiwgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZzogSW5zZXJ0IHRoZSB0b2dnbGUgYmVmb3JlIG9yIGFmdGVyIHRoZSBuYXZpZ2F0aW9uXG4gICAgICAgICAgY3VzdG9tVG9nZ2xlOiBcIlwiLCAgICAgICAgICAgICAgICAgLy8gU2VsZWN0b3I6IFNwZWNpZnkgdGhlIElEIG9mIGEgY3VzdG9tIHRvZ2dsZVxuICAgICAgICAgIGNsb3NlT25OYXZDbGljazogZmFsc2UsICAgICAgICAgICAvLyBCb29sZWFuOiBDbG9zZSB0aGUgbmF2aWdhdGlvbiB3aGVuIG9uZSBvZiB0aGUgbGlua3MgYXJlIGNsaWNrZWRcbiAgICAgICAgICBvcGVuUG9zOiBcInJlbGF0aXZlXCIsICAgICAgICAgICAgICAvLyBTdHJpbmc6IFBvc2l0aW9uIG9mIHRoZSBvcGVuZWQgbmF2LCByZWxhdGl2ZSBvciBzdGF0aWNcbiAgICAgICAgICBuYXZDbGFzczogXCJuYXYtY29sbGFwc2VcIiwgICAgICAgICAvLyBTdHJpbmc6IERlZmF1bHQgQ1NTIGNsYXNzLiBJZiBjaGFuZ2VkLCB5b3UgbmVlZCB0byBlZGl0IHRoZSBDU1MgdG9vIVxuICAgICAgICAgIG5hdkFjdGl2ZUNsYXNzOiBcImpzLW5hdi1hY3RpdmVcIiwgIC8vIFN0cmluZzogQ2xhc3MgdGhhdCBpcyBhZGRlZCB0byA8aHRtbD4gZWxlbWVudCB3aGVuIG5hdiBpcyBhY3RpdmVcbiAgICAgICAgICBqc0NsYXNzOiBcImpzXCIsICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmc6ICdKUyBlbmFibGVkJyBjbGFzcyB3aGljaCBpcyBhZGRlZCB0byA8aHRtbD4gZWxlbWVudFxuICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCl7fSwgICAgICAgICAgICAgICAvLyBGdW5jdGlvbjogSW5pdCBjYWxsYmFja1xuICAgICAgICAgIG9wZW46IGZ1bmN0aW9uKCl7fSwgICAgICAgICAgICAgICAvLyBGdW5jdGlvbjogT3BlbiBjYWxsYmFja1xuICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbigpe30gICAgICAgICAgICAgICAvLyBGdW5jdGlvbjogQ2xvc2UgY2FsbGJhY2tcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVc2VyIGRlZmluZWQgb3B0aW9uc1xuICAgICAgICBmb3IgKGkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHRoaXMub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGRzIFwianNcIiBjbGFzcyBmb3IgPGh0bWw+XG4gICAgICAgIGFkZENsYXNzKGh0bWxFbCwgdGhpcy5vcHRpb25zLmpzQ2xhc3MpO1xuXG4gICAgICAgIC8vIFdyYXBwZXJcbiAgICAgICAgdGhpcy53cmFwcGVyRWwgPSBlbC5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcblxuICAgICAgICAvLyBUcnkgc2VsZWN0aW5nIElEIGZpcnN0XG4gICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLndyYXBwZXJFbCkpIHtcbiAgICAgICAgICB0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLndyYXBwZXJFbCk7XG5cbiAgICAgICAgLy8gSWYgZWxlbWVudCB3aXRoIGFuIElEIGRvZXNuJ3QgZXhpc3QsIHVzZSBxdWVyeVNlbGVjdG9yXG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLndyYXBwZXJFbCkpIHtcbiAgICAgICAgICB0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMud3JhcHBlckVsKTtcblxuICAgICAgICAvLyBJZiBlbGVtZW50IGRvZXNuJ3QgZXhpc3RzLCBzdG9wIGhlcmUuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG5hdiBlbGVtZW50IHlvdSBhcmUgdHJ5aW5nIHRvIHNlbGVjdCBkb2Vzbid0IGV4aXN0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5uZXIgd3JhcHBlclxuICAgICAgICB0aGlzLndyYXBwZXIuaW5uZXIgPSBnZXRDaGlsZHJlbih0aGlzLndyYXBwZXIpO1xuXG4gICAgICAgIC8vIEZvciBtaW5pZmljYXRpb25cbiAgICAgICAgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgbmF2ID0gdGhpcy53cmFwcGVyO1xuXG4gICAgICAgIC8vIEluaXRcbiAgICAgICAgdGhpcy5faW5pdCh0aGlzKTtcbiAgICAgIH07XG5cbiAgICBSZXNwb25zaXZlTmF2LnByb3RvdHlwZSA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVbmF0dGFjaGVzIGV2ZW50cyBhbmQgcmVtb3ZlcyBhbnkgY2xhc3NlcyB0aGF0IHdlcmUgYWRkZWRcbiAgICAgICAqL1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVTdHlsZXMoKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MobmF2LCBcImNsb3NlZFwiKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MobmF2LCBcIm9wZW5lZFwiKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MobmF2LCBvcHRzLm5hdkNsYXNzKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MobmF2LCBvcHRzLm5hdkNsYXNzICsgXCItXCIgKyB0aGlzLmluZGV4KTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoaHRtbEVsLCBvcHRzLm5hdkFjdGl2ZUNsYXNzKTtcbiAgICAgICAgbmF2LnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICBuYXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XG5cbiAgICAgICAgcmVtb3ZlRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZUV2ZW50KHdpbmRvdywgXCJmb2N1c1wiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZUV2ZW50KGRvY3VtZW50LmJvZHksIFwidG91Y2htb3ZlXCIsIHRoaXMsIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlRXZlbnQobmF2VG9nZ2xlLCBcInRvdWNoc3RhcnRcIiwgdGhpcywgZmFsc2UpO1xuICAgICAgICByZW1vdmVFdmVudChuYXZUb2dnbGUsIFwidG91Y2hlbmRcIiwgdGhpcywgZmFsc2UpO1xuICAgICAgICByZW1vdmVFdmVudChuYXZUb2dnbGUsIFwibW91c2V1cFwiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZUV2ZW50KG5hdlRvZ2dsZSwgXCJrZXl1cFwiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZUV2ZW50KG5hdlRvZ2dsZSwgXCJjbGlja1wiLCB0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKCFvcHRzLmN1c3RvbVRvZ2dsZSkge1xuICAgICAgICAgIG5hdlRvZ2dsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5hdlRvZ2dsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmF2VG9nZ2xlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgdGhlIG5hdmlnYXRpb24gb3Blbi9jbG9zZVxuICAgICAgICovXG4gICAgICB0b2dnbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGhhc0FuaW1GaW5pc2hlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICghbmF2T3Blbikge1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogT3BlbnMgdGhlIG5hdmlnYXRpb25cbiAgICAgICAqL1xuICAgICAgb3BlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIW5hdk9wZW4pIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyhuYXYsIFwiY2xvc2VkXCIpO1xuICAgICAgICAgIGFkZENsYXNzKG5hdiwgXCJvcGVuZWRcIik7XG4gICAgICAgICAgYWRkQ2xhc3MoaHRtbEVsLCBvcHRzLm5hdkFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICBhZGRDbGFzcyhuYXZUb2dnbGUsIFwiYWN0aXZlXCIpO1xuICAgICAgICAgIG5hdi5zdHlsZS5wb3NpdGlvbiA9IG9wdHMub3BlblBvcztcbiAgICAgICAgICBzZXRBdHRyaWJ1dGVzKG5hdiwge1wiYXJpYS1oaWRkZW5cIjogXCJmYWxzZVwifSk7XG4gICAgICAgICAgbmF2T3BlbiA9IHRydWU7XG4gICAgICAgICAgb3B0cy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xvc2VzIHRoZSBuYXZpZ2F0aW9uXG4gICAgICAgKi9cbiAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXZPcGVuKSB7XG4gICAgICAgICAgYWRkQ2xhc3MobmF2LCBcImNsb3NlZFwiKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyhuYXYsIFwib3BlbmVkXCIpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGh0bWxFbCwgb3B0cy5uYXZBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MobmF2VG9nZ2xlLCBcImFjdGl2ZVwiKTtcbiAgICAgICAgICBzZXRBdHRyaWJ1dGVzKG5hdiwge1wiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJ9KTtcblxuICAgICAgICAgIC8vIElmIGFuaW1hdGlvbnMgYXJlIGVuYWJsZWQsIHdhaXQgdW50aWwgdGhleSBmaW5pc2hcbiAgICAgICAgICBpZiAob3B0cy5hbmltYXRlKSB7XG4gICAgICAgICAgICBoYXNBbmltRmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBuYXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICAgIGhhc0FuaW1GaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9LCBvcHRzLnRyYW5zaXRpb24gKyAxMCk7XG5cbiAgICAgICAgICAvLyBBbmltYXRpb25zIGFyZW4ndCBlbmFibGVkLCB3ZSBjYW4gZG8gdGhlc2UgaW1tZWRpYXRlbHlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmF2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5hdk9wZW4gPSBmYWxzZTtcbiAgICAgICAgICBvcHRzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVzaXplIGlzIGNhbGxlZCBvbiB3aW5kb3cgcmVzaXplIGFuZCBvcmllbnRhdGlvbiBjaGFuZ2UuXG4gICAgICAgKiBJdCBpbml0aWFsaXplcyB0aGUgQ1NTIHN0eWxlcyBhbmQgaGVpZ2h0IGNhbGN1bGF0aW9ucy5cbiAgICAgICAqL1xuICAgICAgcmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLy8gUmVzaXplIHdhdGNoZXMgbmF2aWdhdGlvbiB0b2dnbGUncyBkaXNwbGF5IHN0YXRlXG4gICAgICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShuYXZUb2dnbGUsIG51bGwpLmdldFByb3BlcnR5VmFsdWUoXCJkaXNwbGF5XCIpICE9PSBcIm5vbmVcIikge1xuXG4gICAgICAgICAgaXNNb2JpbGUgPSB0cnVlO1xuICAgICAgICAgIHNldEF0dHJpYnV0ZXMobmF2VG9nZ2xlLCB7XCJhcmlhLWhpZGRlblwiOiBcImZhbHNlXCJ9KTtcblxuICAgICAgICAgIC8vIElmIHRoZSBuYXZpZ2F0aW9uIGlzIGhpZGRlblxuICAgICAgICAgIGlmIChuYXYuY2xhc3NOYW1lLm1hdGNoKC8oXnxcXHMpY2xvc2VkKFxcc3wkKS8pKSB7XG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGVzKG5hdiwge1wiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJ9KTtcbiAgICAgICAgICAgIG5hdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9jcmVhdGVTdHlsZXMoKTtcbiAgICAgICAgICB0aGlzLl9jYWxjSGVpZ2h0KCk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBpc01vYmlsZSA9IGZhbHNlO1xuICAgICAgICAgIHNldEF0dHJpYnV0ZXMobmF2VG9nZ2xlLCB7XCJhcmlhLWhpZGRlblwiOiBcInRydWVcIn0pO1xuICAgICAgICAgIHNldEF0dHJpYnV0ZXMobmF2LCB7XCJhcmlhLWhpZGRlblwiOiBcImZhbHNlXCJ9KTtcbiAgICAgICAgICBuYXYuc3R5bGUucG9zaXRpb24gPSBvcHRzLm9wZW5Qb3M7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlU3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGFrZXMgY2FyZSBvZiBhbGwgZXZlbiBoYW5kbGluZ1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge2V2ZW50fSBldmVudFxuICAgICAgICogQHJldHVybiB7dHlwZX0gcmV0dXJucyB0aGUgdHlwZSBvZiBldmVudCB0aGF0IHNob3VsZCBiZSB1c2VkXG4gICAgICAgKi9cbiAgICAgIGhhbmRsZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZXZ0ID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgc3dpdGNoIChldnQudHlwZSkge1xuICAgICAgICBjYXNlIFwidG91Y2hzdGFydFwiOlxuICAgICAgICAgIHRoaXMuX29uVG91Y2hTdGFydChldnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG91Y2htb3ZlXCI6XG4gICAgICAgICAgdGhpcy5fb25Ub3VjaE1vdmUoZXZ0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRvdWNoZW5kXCI6XG4gICAgICAgIGNhc2UgXCJtb3VzZXVwXCI6XG4gICAgICAgICAgdGhpcy5fb25Ub3VjaEVuZChldnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2xpY2tcIjpcbiAgICAgICAgICB0aGlzLl9wcmV2ZW50RGVmYXVsdChldnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwia2V5dXBcIjpcbiAgICAgICAgICB0aGlzLl9vbktleVVwKGV2dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmb2N1c1wiOlxuICAgICAgICBjYXNlIFwicmVzaXplXCI6XG4gICAgICAgICAgdGhpcy5yZXNpemUoZXZ0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBJbml0aWFsaXplcyB0aGUgd2lkZ2V0XG4gICAgICAgKi9cbiAgICAgIF9pbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleCsrO1xuXG4gICAgICAgIGFkZENsYXNzKG5hdiwgb3B0cy5uYXZDbGFzcyk7XG4gICAgICAgIGFkZENsYXNzKG5hdiwgb3B0cy5uYXZDbGFzcyArIFwiLVwiICsgdGhpcy5pbmRleCk7XG4gICAgICAgIGFkZENsYXNzKG5hdiwgXCJjbG9zZWRcIik7XG4gICAgICAgIGhhc0FuaW1GaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIG5hdk9wZW4gPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9jbG9zZU9uTmF2Q2xpY2soKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlVG9nZ2xlKCk7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25zKCk7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9uIElFOCB0aGUgcmVzaXplIGV2ZW50IHRyaWdnZXJzIHRvbyBlYXJseSBmb3Igc29tZSByZWFzb25cbiAgICAgICAgICogc28gaXQncyBjYWxsZWQgaGVyZSBhZ2FpbiBvbiBpbml0IHRvIG1ha2Ugc3VyZSBhbGwgdGhlXG4gICAgICAgICAqIGNhbGN1bGF0ZWQgc3R5bGVzIGFyZSBjb3JyZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLnJlc2l6ZSgpO1xuICAgICAgICB9LCAyMCk7XG5cbiAgICAgICAgYWRkRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIGFkZEV2ZW50KHdpbmRvdywgXCJmb2N1c1wiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIGFkZEV2ZW50KGRvY3VtZW50LmJvZHksIFwidG91Y2htb3ZlXCIsIHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYWRkRXZlbnQobmF2VG9nZ2xlLCBcInRvdWNoc3RhcnRcIiwgdGhpcywgZmFsc2UpO1xuICAgICAgICBhZGRFdmVudChuYXZUb2dnbGUsIFwidG91Y2hlbmRcIiwgdGhpcywgZmFsc2UpO1xuICAgICAgICBhZGRFdmVudChuYXZUb2dnbGUsIFwibW91c2V1cFwiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIGFkZEV2ZW50KG5hdlRvZ2dsZSwgXCJrZXl1cFwiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIGFkZEV2ZW50KG5hdlRvZ2dsZSwgXCJjbGlja1wiLCB0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXQgY2FsbGJhY2sgaGVyZVxuICAgICAgICAgKi9cbiAgICAgICAgb3B0cy5pbml0KCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgU3R5bGVzIHRvIHRoZSA8aGVhZD5cbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZVN0eWxlczogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXN0eWxlRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgc3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XG4gICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBzdHlsZXMgZnJvbSB0aGUgPGhlYWQ+XG4gICAgICAgKi9cbiAgICAgIF9yZW1vdmVTdHlsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIE5hdmlnYXRpb24gVG9nZ2xlXG4gICAgICAgKi9cbiAgICAgIF9jcmVhdGVUb2dnbGU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHRvZ2dsZSwgbGV0J3MgY3JlYXRlIG9uZVxuICAgICAgICBpZiAoIW9wdHMuY3VzdG9tVG9nZ2xlKSB7XG4gICAgICAgICAgdmFyIHRvZ2dsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgdmFyIGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIHRvZ2dsZS5pbm5lckhUTUwgPSBvcHRzLmxhYmVsO1xuICAgICAgICAgIHNldEF0dHJpYnV0ZXModG9nZ2xlLCB7XG4gICAgICAgICAgICBcImhyZWZcIjogXCIjXCIsXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwibmF2LXRvZ2dsZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWNvbi5jbGFzc05hbWUgPSAnbmF2LXRvZ2dsZS1pY29uJztcbiAgICAgICAgICB0b2dnbGUuYXBwZW5kQ2hpbGQoaWNvbik7XG5cbiAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hlcmUgdG8gaW5zZXJ0IHRoZSB0b2dnbGVcbiAgICAgICAgICBpZiAob3B0cy5pbnNlcnQgPT09IFwiYWZ0ZXJcIikge1xuICAgICAgICAgICAgbmF2LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRvZ2dsZSwgbmF2Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmF2LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRvZ2dsZSwgbmF2KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuYXZUb2dnbGUgPSB0b2dnbGU7XG5cbiAgICAgICAgLy8gVGhlcmUgaXMgYSB0b2dnbGUgYWxyZWFkeSwgbGV0J3MgdXNlIHRoYXQgb25lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRvZ2dsZUVsID0gb3B0cy5jdXN0b21Ub2dnbGUucmVwbGFjZShcIiNcIiwgXCJcIik7XG5cbiAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodG9nZ2xlRWwpKSB7XG4gICAgICAgICAgICBuYXZUb2dnbGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0b2dnbGVFbCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRvZ2dsZUVsKSkge1xuICAgICAgICAgICAgbmF2VG9nZ2xlID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0b2dnbGVFbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjdXN0b20gbmF2IHRvZ2dsZSB5b3UgYXJlIHRyeWluZyB0byBzZWxlY3QgZG9lc24ndCBleGlzdFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xvc2VzIHRoZSBuYXZpZ2F0aW9uIHdoZW4gYSBsaW5rIGluc2lkZSBpcyBjbGlja2VkLlxuICAgICAgICovXG4gICAgICBfY2xvc2VPbk5hdkNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvcHRzLmNsb3NlT25OYXZDbGljaykge1xuICAgICAgICAgIHZhciBsaW5rcyA9IG5hdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFcIiksXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICBmb3JFYWNoKGxpbmtzLCBmdW5jdGlvbiAoaSwgZWwpIHtcbiAgICAgICAgICAgIGFkZEV2ZW50KGxpbmtzW2ldLCBcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi50b2dnbGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7ZXZlbnR9IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIF9wcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgIGlmIChlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIFRoaXMgaXMgc3RyaWN0bHkgZm9yIG9sZCBJRVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBPbiB0b3VjaCBzdGFydCB3ZSBnZXQgdGhlIGxvY2F0aW9uIG9mIHRoZSB0b3VjaC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gIHtldmVudH0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgX29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFFdmVudC5wcm90b3R5cGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFggPSBlLnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgdGhpcy5zdGFydFkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgdGhpcy50b3VjaEhhc01vdmVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBtb3VzZXVwIGV2ZW50IGNvbXBsZXRlbHkgaGVyZSB0byBhdm9pZFxuICAgICAgICAgKiBkb3VibGUgdHJpZ2dlcmluZyB0aGUgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVFdmVudChuYXZUb2dnbGUsIFwibW91c2V1cFwiLCB0aGlzLCBmYWxzZSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGlmIHRoZSB1c2VyIGlzIHNjcm9sbGluZyBpbnN0ZWFkIG9mIHRhcHBpbmcuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7ZXZlbnR9IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGUudG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy5zdGFydFgpID4gMTAgfHxcbiAgICAgICAgTWF0aC5hYnMoZS50b3VjaGVzWzBdLmNsaWVudFkgLSB0aGlzLnN0YXJ0WSkgPiAxMCkge1xuICAgICAgICAgIHRoaXMudG91Y2hIYXNNb3ZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogT24gdG91Y2ggZW5kIHRvZ2dsZSB0aGUgbmF2aWdhdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gIHtldmVudH0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgX29uVG91Y2hFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICBpZiAoIWlzTW9iaWxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaXNuJ3Qgc2Nyb2xsaW5nXG4gICAgICAgIGlmICghdGhpcy50b3VjaEhhc01vdmVkKSB7XG5cbiAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgdHlwZSBpcyB0b3VjaFxuICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwidG91Y2hlbmRcIikge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIC8vIEV2ZW50IHR5cGUgd2FzIGNsaWNrLCBub3QgdG91Y2hcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV2dCA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgICAgICAgICAvLyBJZiBpdCBpc24ndCBhIHJpZ2h0IGNsaWNrLCBkbyB0b2dnbGluZ1xuICAgICAgICAgICAgaWYgKCEoZXZ0LndoaWNoID09PSAzIHx8IGV2dC5idXR0b24gPT09IDIpKSB7XG4gICAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEZvciBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5LCB0b2dnbGUgdGhlIG5hdmlnYXRpb24gb24gRW50ZXJcbiAgICAgICAqIGtleXByZXNzIHRvby5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gIHtldmVudH0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgX29uS2V5VXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBldnQgPSBlIHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgaWYgKGV2dC5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyB0aGUgbmVlZGVkIENTUyB0cmFuc2l0aW9ucyBpZiBhbmltYXRpb25zIGFyZSBlbmFibGVkXG4gICAgICAgKi9cbiAgICAgIF90cmFuc2l0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAob3B0cy5hbmltYXRlKSB7XG4gICAgICAgICAgdmFyIG9ialN0eWxlID0gbmF2LnN0eWxlLFxuICAgICAgICAgICAgdHJhbnNpdGlvbiA9IFwibWF4LWhlaWdodCBcIiArIG9wdHMudHJhbnNpdGlvbiArIFwibXNcIjtcblxuICAgICAgICAgIG9ialN0eWxlLldlYmtpdFRyYW5zaXRpb24gPVxuICAgICAgICAgIG9ialN0eWxlLk1velRyYW5zaXRpb24gPVxuICAgICAgICAgIG9ialN0eWxlLk9UcmFuc2l0aW9uID1cbiAgICAgICAgICBvYmpTdHlsZS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxjdWxhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIG5hdmlnYXRpb24gYW5kIHRoZW4gY3JlYXRlc1xuICAgICAgICogc3R5bGVzIHdoaWNoIGFyZSBsYXRlciBhZGRlZCB0byB0aGUgcGFnZSA8aGVhZD5cbiAgICAgICAqL1xuICAgICAgX2NhbGNIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNhdmVkSGVpZ2h0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYXYuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzYXZlZEhlaWdodCArPSBuYXYuaW5uZXJbaV0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlubmVyU3R5bGVzID0gXCIuXCIgKyBvcHRzLmpzQ2xhc3MgKyBcIiAuXCIgKyBvcHRzLm5hdkNsYXNzICsgXCItXCIgKyB0aGlzLmluZGV4ICsgXCIub3BlbmVke21heC1oZWlnaHQ6XCIgKyBzYXZlZEhlaWdodCArIFwicHggIWltcG9ydGFudH0gLlwiICsgb3B0cy5qc0NsYXNzICsgXCIgLlwiICsgb3B0cy5uYXZDbGFzcyArIFwiLVwiICsgdGhpcy5pbmRleCArIFwiLm9wZW5lZC5kcm9wZG93bi1hY3RpdmUge21heC1oZWlnaHQ6OTk5OXB4ICFpbXBvcnRhbnR9XCI7XG5cbiAgICAgICAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGlubmVyU3R5bGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBpbm5lclN0eWxlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlubmVyU3R5bGVzID0gXCJcIjtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbmV3IFJlc3BvbnNpdmUgTmF2XG4gICAgICovXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zaXZlTmF2KGVsLCBvcHRpb25zKTtcblxuICB9O1xuXG4gIHdpbmRvdy5yZXNwb25zaXZlTmF2ID0gcmVzcG9uc2l2ZU5hdjtcblxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQVNBO0FBVEE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXNCQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBalpBO0FBQ0E7QUFtWkE7OztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _responsiveNav = __webpack_require__(0);\n\nvar _responsiveNav2 = _interopRequireDefault(_responsiveNav);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar displayResponsiveNav = (0, _responsiveNav2.default)(document, window, 0); /*!\n                                                                               * Sonnie Nguyen's Portfolio Website\n                                                                               * Copyright 2017-2018 Sonnie Nguyen <info@sonnienguyen.com> | @sonnienguyen\n                                                                               * Licensed under MIT (https://github.com/sonnienguyen/sonnienguyen.github.io/blob/master/LICENSE)\n                                                                               *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvdmVuZG9yLmpzPzhjOGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBTb25uaWUgTmd1eWVuJ3MgUG9ydGZvbGlvIFdlYnNpdGVcbiAqIENvcHlyaWdodCAyMDE3LTIwMTggU29ubmllIE5ndXllbiA8aW5mb0Bzb25uaWVuZ3V5ZW4uY29tPiB8IEBzb25uaWVuZ3V5ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3Nvbm5pZW5ndXllbi9zb25uaWVuZ3V5ZW4uZ2l0aHViLmlvL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKi9cblxuaW1wb3J0IHJlc3BvbnNpdmVOYXYgZnJvbSAnLi92ZW5kb3IvcmVzcG9uc2l2ZU5hdic7XG5cbmNvbnN0IGRpc3BsYXlSZXNwb25zaXZlTmF2ID0gcmVzcG9uc2l2ZU5hdihkb2N1bWVudCwgd2luZG93LCAwKTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFNQTtBQUNBOzs7OztBQUNBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")}]);